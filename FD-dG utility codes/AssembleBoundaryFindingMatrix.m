function [E_gamma,E_gamma_t,permInds,indicesOnInterface,E_E,E_S,E_W,bdryIndices,n_E,n_S]=AssembleBoundaryFindingMatrix(edG,tdG,P,T,order,EdgeLabels)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% DESCRIPTION: Find matrices E which picks out the DOFS along a given FE
%              discretization of a domain, in particular adapted to have 
%              the interface along the northern boundary.
%              
%
% INPUT : - edG,tdG: edge and triangulation data from the [p,e,t] structure
%                    generated by matlab for a given triangulation on a P^1
%                    element
%
%         - P,T:     point vector (P) and triangulation matrix (T) obtained
%                    for the dG method of the current order
%
%         - order:   polynomial order of the dG method used
%
%         - EdgeLabels: a vector containing the boundary indices given by the
%                     geometry object ordered north-> east -> south ->
%                     west, obtained by plotting
%                     "pdegplot(g,'EdgeLabels',"on")
%
% OUTPUT: - E_gamma: a diagonal matrix with non-zeros only at the DOFS 
%                    corresponding to the interface, currently set to be 
%                    the northern boundar. At these points it takes the
%                    value 1.
%
%         - E_gamma_t: a diagonal matrix that also picks up the DOFS
%                      within the elements adjacent to the boundary. Needed
%                      for traction.
%
%         - permInds: a vector used to sort the DOFS along the interface
%
%         - indicesOnInterface: a vector containing DOFS along interface
%                               (northern boundary)
%
%         - E_E,E_N,E_S: matrices picking up the DOFS along the eastern,
%                        northern and southern boundaries respectively
%
%        - bdryIndices: a vector containing the DOFS along the boundary
%
%        - n_E,n_S: number of dofs along the eastern and southern
%                    boundaries respectively.
%
% AUTHOR:  Andreas Granath (andreas.granath@umu.se)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% edge-to-node tables depending on the dG order used

if order==3
    e2n=[2,4,5,3;3,6,7,1;1,8,9,2];
elseif order==4
    e2n=[2,4,5,6,3;3,7,8,9,1;1,10,11,12,2];
end

% Number of points per side of dG element
N=order+1;

% Number of points in total
NDoFs=length(T(1,:))*(order+1)*(order+2)/2;
% Locate each respective edge to one of the four boundaries

Interface_edge_Indices=find(edG(5,:)==EdgeLabels(1));
East_indices=find(edG(5,:)==EdgeLabels(2)); 
South_indices=find(edG(5,:)==EdgeLabels(3));
West_indices=find(edG(5,:)==EdgeLabels(4));

% Find the limits of each boundary

Interface_edge_limits=zeros(2,length(Interface_edge_Indices));
Interface_edge_limits(1,:)=edG(1,Interface_edge_Indices);
Interface_edge_limits(2,:)=edG(2,Interface_edge_Indices);

E_edge_limits=zeros(2,length(East_indices));
E_edge_limits(1,:)=edG(1,East_indices);
E_edge_limits(2,:)=edG(2,East_indices);

W_edge_limits=zeros(2,length(West_indices));
W_edge_limits(1,:)=edG(1,West_indices);
W_edge_limits(2,:)=edG(2,West_indices);

S_edge_limits=zeros(2,length(South_indices));
S_edge_limits(1,:)=edG(1,South_indices);
S_edge_limits(2,:)=edG(2,South_indices);

% Determine number of edges in each direction

numEdges_yS=(length(South_indices));
numEdges_y=(length(Interface_edge_Indices));
numEdges_x=(length(East_indices));

edgeElement=zeros(1,numEdges_y);
edgeElementS=zeros(1,numEdges_y);
edgeElementE=zeros(1,numEdges_x);
edgeElementW=zeros(1,numEdges_x);

% Find each edge element
for i=1:numEdges_y
    [~,cols1]=find(tdG(1:3,:)==Interface_edge_limits(1,i));
    [~,cols2]=find(tdG(1:3,:)==Interface_edge_limits(2,i));
    edgeElement(i)=intersect(cols1,cols2,'stable');    
end

for i=1:numEdges_yS
     [~,cols1]=find(tdG(1:3,:)==S_edge_limits(1,i));
      [~,cols2]=find(tdG(1:3,:)==S_edge_limits(2,i));
      edgeElementS(i)=intersect(cols1,cols2,'stable');
end


for i=1:numEdges_x
    [~,cols1]=find(tdG(1:3,:)==W_edge_limits(1,i));
    [~,cols2]=find(tdG(1:3,:)==W_edge_limits(2,i));
    edgeElementW(i)=intersect(cols1,cols2,'stable');

      [~,cols1]=find(tdG(1:3,:)==E_edge_limits(1,i));
      [~,cols2]=find(tdG(1:3,:)==E_edge_limits(2,i));
      edgeElementE(i)=intersect(cols1,cols2,'stable');
end

T_interface=T(:,edgeElement);
T_east=T(:,edgeElementE); T_west=T(:,edgeElementW);
T_south=T(:,edgeElementS);

nPts=(order+1)*(order+2)*0.5;

AllIndicesNearInterface=reshape(T_interface,[1 nPts*numEdges_y]);
AllIndicesNearSouth=reshape(T_south,[1 nPts*numEdges_yS]);


% Determine which edge it is on the element

for i=1:length(edgeElement)
    currElement=edgeElement(i);

    e_l1=Interface_edge_limits(1,i); e_l2=Interface_edge_limits(2,i);
    Inds=[find(tdG(1+3*(currElement-1):3*currElement)==e_l1),find(tdG(1+3*(currElement-1):3*currElement)==e_l2)];

    if sort(Inds)==[1,2]
        edges=3;
    elseif sort(Inds)==[2,3]
        edges=1;
    else
        edges=2;
    end
    e2n_loc=e2n(edges,:);
    indicesOnInterface(1,1+N*(i-1):N*i)=T_interface(e2n_loc,i)';
end

for i=1:length(edgeElementS)
    currElement=edgeElementS(i);

    e_l1=S_edge_limits(1,i); e_l2=S_edge_limits(2,i);
    Inds=[find(tdG(1+3*(currElement-1):3*currElement)==e_l1),find(tdG(1+3*(currElement-1):3*currElement)==e_l2)];

    if sort(Inds)==[1,2]
        edges=3;
    elseif sort(Inds)==[2,3]
        edges=1;
    else
        edges=2;
    end
    e2n_loc=e2n(edges,:);
    indicesOnInterfaceS(1,1+N*(i-1):N*i)=T_south(e2n_loc,i)';
end

for i=1:length(edgeElementE)
    currElement=edgeElementE(i);

    e_l1=E_edge_limits(1,i); e_l2=E_edge_limits(2,i);
    Inds=[find(tdG(1+3*(currElement-1):3*currElement)==e_l1),find(tdG(1+3*(currElement-1):3*currElement)==e_l2)];

    if sort(Inds)==[1,2]
        edges=3;
    elseif sort(Inds)==[2,3]
        edges=1;
    else
        edges=2;
    end
    e2n_loc=e2n(edges,:);
    indicesOnInterfaceE(1,1+N*(i-1):N*i)=T_east(e2n_loc,i)';
end

for i=1:length(edgeElementW)
    currElement=edgeElementW(i);

    e_l1=W_edge_limits(1,i); e_l2=W_edge_limits(2,i);
    Inds=[find(tdG(1+3*(currElement-1):3*currElement)==e_l1),find(tdG(1+3*(currElement-1):3*currElement)==e_l2)];

    if sort(Inds)==[1,2]
        edges=3;
    elseif sort(Inds)==[2,3]
        edges=1;
    else
        edges=2;
    end
    e2n_loc=e2n(edges,:);
    indicesOnInterfaceW(1,1+N*(i-1):N*i)=T_west(e2n_loc,i)';
end

%




nm=max([length(indicesOnInterfaceE),length(indicesOnInterfaceS),length(indicesOnInterfaceW)]);


Pw=P(:,indicesOnInterfaceW); Pe=P(:,indicesOnInterfaceE); Ps=P(:,indicesOnInterfaceS);
Pn=P(:,indicesOnInterface);
[~,permInds]=sort(Pn(1,:));
[~,permIndsW]=sort(Pw(2,:)); 
[~,permIndsE]=sort(Pe(2,:)); [~,permIndsS]=sort(Ps(1,:));


%%



E_S=sparse(NDoFs,NDoFs); E_E=sparse(NDoFs,NDoFs); E_W=sparse(NDoFs,NDoFs);

E_S=sparse(NDoFs,1); E_S(indicesOnInterfaceS(permIndsS))=1;
E_S=diag(E_S);

E_W=sparse(NDoFs,1); E_W(indicesOnInterfaceW(permIndsW))=1;
E_W=diag(E_W);

E_E=sparse(NDoFs,1); E_E(indicesOnInterfaceE(permIndsE))=1;
E_E=diag(E_E);

E_gamma=sparse(NDoFs,1); E_gamma(indicesOnInterface(permInds))=1;
E_gamma=diag(E_gamma);


E_gamma_t=sparse(NDoFs,1); E_gamma_t(AllIndicesNearInterface)=1;
E_gamma_t=diag(E_gamma_t);



% Determine number of elements on eastern and southern interface (only
% relevant when there are equal number of elements on N and S or W and E
% respectively)

n_E=length(East_indices);
n_S=length(South_indices);

% Sort DOFS to follow placement from left to right

indicesOnInterfaceW=indicesOnInterfaceW(permIndsW);
indicesOnInterfaceE=indicesOnInterfaceE(permIndsE);
indicesOnInterfaceS=indicesOnInterfaceS(permIndsS);

% Assemble the boundary indices into one matrix
bdryIndices=zeros(3,nm);
bdryIndices(1,1:length(indicesOnInterfaceE))=indicesOnInterfaceE; bdryIndices(2,1:length(indicesOnInterfaceS))=indicesOnInterfaceS; bdryIndices(3,1:length(indicesOnInterfaceW))=indicesOnInterfaceW;

end